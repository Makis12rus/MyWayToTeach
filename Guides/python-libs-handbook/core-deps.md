# 🧱 Основные зависимости проекта: изоляция окружения, фиксация версий и установка пакетов

Эти зависимости помогают создать изолированное рабочее пространство для Python-проекта, зафиксировать версии пакетов и повторяемо устанавливать всё нужное на любой машине. Идея проста: у вас есть свой «песочница-проект», где пакеты не конфликтуют с системными, а версии не пляшут от настроения интернета. Вы создаёте виртуальное окружение, ставите зависимости строго туда, фиксируете их версии и получаете стабильный запуск кода сегодня, завтра и на ноутбуке коллеги.

В этом гайде мы разложим по полочкам базовые инструменты: от стандартных (венв и пип) до современных менеджеров, которые умеют lock-файлы и автоматизируют рутину. Важно: все установки выполняйте только в активированном виртуальном окружении проекта.

## Содержание 🧭

* [venv](#venv) — стандартный модуль для создания виртуальных окружений.
* [pip](#pip) — установщик пакетов и зависимостей в активном окружении.
* [uv](#uv) — быстрый менеджер пакетов и окружений с lock-файлом.
* [pip-tools](#pip-tools) — фиксирует версии и синхронизирует окружение.
* [virtualenv](#virtualenv) — альтернатива venv с дополнительными возможностями.
* [Poetry](#poetry) — менеджер зависимостей через `pyproject.toml` и lock-файл.
* [PDM](#pdm) — современный менеджер зависимостей по актуальным PEP, с lock.
* [Rye](#rye) — единый инструмент: версии Python, зависимости и окружения.
* [Pipenv](#pipenv) — менеджер зависимостей с автоматическим venv и lock.

## venv

**venv** — стандартный модуль Python для создания изолированных виртуальных окружений внутри проекта. Такое окружение хранит свои собственные пакеты и не трогает системный Python. Это помогает запускать код предсказуемо на любой машине.

---

### 🚀 Шаг 1: Создаём виртуальное окружение

В терминале, находясь в корне вашего проекта, выполните команду:

```bash
python -m venv .venv
```

👉 **Что делает команда?** Запускается модуль `venv`, который создаёт новую папку `.venv` со своим интерпретатором Python и директорией для пакетов. Точка перед именем делает папку скрытой в Unix‑системах и помогает держать порядок в корне проекта.

**Ожидаемый результат:** в проекте появится папка `.venv/` со служебными файлами и каталогами (`Scripts` или `bin`, `Lib` и т. п.).

---

### 🔑 Шаг 2: Активируем окружение

Активируйте окружение, чтобы все установки и запуск кода происходили именно внутри `.venv`.

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

👉 Делает текущее окно PowerShell «подключённым» к окружению `.venv`. В начале строки появится префикс `(.venv)`.

**Windows (cmd.exe):**

```bat
.\.venv\Scripts\activate.bat
```

👉 То же самое, но для классической командной строки.

**macOS/Linux (bash/zsh):**

```bash
source .venv/bin/activate
```

👉 Команда `source` исполняет скрипт активации и меняет переменные среды текущего процесса.

**Ожидаемый результат:**

```text
(.venv) yourname@host project-dir $
```

Префикс `(.venv)` указывает, что вы находитесь внутри виртуального окружения.

> Чтобы выйти из окружения в любом терминале:

```bash
deactivate
```

👉 Возвращает терминал к системному Python и его пакетам.

---

### 🛠️ Шаг 3: Обновляем `pip` внутри окружения

Сразу после активации разумно обновить менеджер пакетов:

```bash
python -m pip install --upgrade pip
```

👉 Запускает встроенный модуль `pip` текущего окружения и обновляет его до свежей версии. Это уменьшает шансы на ошибки при установке пакетов.

**Ожидаемый результат:** сообщения об установке/обновлении `pip` и зависимостей (если требуются), завершение без ошибок.

---

### 📦 Шаг 4: Устанавливаем пакеты только внутрь активированного окружения

Для примера установим библиотеку:

```bash
pip install requests
```

👉 Устанавливает пакет `requests` **внутрь** активированного окружения `.venv`. В неактивированном состоянии пакет ушёл бы в системные каталоги, что нам не нужно.

Проверим, что пакет виден из окружения:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Импортирует `requests`, печатает «OK», установленную версию и путь к интерпретатору. Путь должен указывать на `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 📜 Шаг 5: «Импорт» для `venv`

Импорт в коде не требуется. `venv` используется как модуль из командной строки. Полезно знать, как получить помощь по опциям:

```bash
python -m venv --help
```

👉 Показывает краткую справку по аргументам (`--prompt`, `--upgrade-deps` и др.).

---

### 🎉 Результат (что должно получиться?)

Структура проекта после шагов выше может выглядеть так:

```text
project/
├─ .venv/
│  ├─ bin/ (или Scripts/ на Windows)
│  ├─ lib/ (site-packages внутри)
│  └─ ...
├─ requirements.txt  (опционально, если будете фиксировать версии)
└─ your_code.py
```

👉 У вас есть изолированное окружение с собственным Python и пакетами. Все дальнейшие команды `pip install ...` выполняйте **только** после активации окружения, чтобы зависимости устанавливались в `.venv` и проект был воспроизводимым.

## pip

**pip** — штатный установщик пакетов для Python. Работает из активированного интерпретатора и устанавливает зависимости **в текущее виртуальное окружение** проекта. Это гарантирует, что пакеты не смешаются с системными и код запустится предсказуемо.

---

### 🚀 Шаг 1: Проверяем и обновляем `pip` в активированном окружении

```bash
python -m pip --version
```

👉 Показывает версию и путь до исполняемого файла. Убедитесь, что путь указывает на ваш `.venv`.

```bash
python -m pip install --upgrade pip
```

👉 Обновляет `pip` **внутри текущего окружения** до актуальной версии, чтобы установка пакетов проходила стабильнее.

**Ожидаемый результат (пример):**

```text
pip 24.x from /path/to/project/.venv/lib/python... (python 3.x)
Successfully installed pip-24.x
```

---

### 📦 Шаг 2: Устанавливаем пакеты

```bash
python -m pip install requests
```

👉 Устанавливает пакет `requests` в активированное окружение.

```bash
python -m pip install "requests==2.32.3"
```

👉 Ставит **точную** версию. Полезно для воспроизводимости.

```bash
python -m pip install "urllib3>=2.2"
```

👉 Ставит минимально подходящую версию, если вам важна «не ниже чем».

```bash
python -m pip install -r requirements.txt
```

👉 Устанавливает все зависимости из файла `requirements.txt` (каждая строка — пакет и версия).

**Ожидаемый результат:** логи установки без ошибок. Пакеты доступны в проекте.

---

### 🔍 Шаг 3: Проверяем, что пакет поставился в правильное место

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Импортирует пакет, печатает его версию и путь к интерпретатору. Путь должен вести на `.venv` вашего проекта.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 4: Фиксируем версии зависимостей

```bash
python -m pip freeze > requirements.txt
```

👉 Сохраняет **точные** версии всех установленных пакетов в `requirements.txt`, чтобы другой человек мог получить те же версии.

```bash
python -m pip install -r requirements.txt
```

👉 Воссоздаёт окружение с теми же версиями из `requirements.txt`.

> Продвинутый вариант: проверка хешей.

```bash
python -m pip install --require-hashes -r requirements.txt
```

👉 Строгая установка по файлу, где у каждой строки должны быть `--hash=sha256:...`. Это повышает безопасность и детерминизм.

**Пример фрагмента `requirements.txt` для `--require-hashes` (схема):**

```text
requests==2.32.3 \
    --hash=sha256:<hash1> \
    --hash=sha256:<hash2>
```

---

### 🧹 Шаг 5: Обновления, удаление и диагностика

```bash
python -m pip install -U requests
```

👉 Обновляет пакет до последней доступной версии в рамках ограничений зависимостей.

```bash
python -m pip uninstall requests
```

👉 Удаляет пакет из текущего окружения.

```bash
python -m pip list
```

👉 Показывает установленные пакеты и их версии.

```bash
python -m pip show requests
```

👉 Выводит подробности по конкретному пакету: версия, путь установки, зависимости.

```bash
python -m pip check
```

👉 Проверяет, нет ли конфликтов зависимостей в окружении.

```bash
python -m pip cache purge
```

👉 Очищает кэш `pip`, если нужно освободить место или устранить проблемы с повреждёнными файлами.

**Ожидаемый результат:** пакеты ставятся/обновляются, конфликты видны через `pip check`, окружение чистое и воспроизводимое.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/
├─ requirements.txt   # зафиксированный список версий
└─ your_code.py
```

👉 Вы устанавливаете все зависимости **только внутри активированного окружения**, фиксируете версии в `requirements.txt` и можете воссоздать проект на любой машине без сюрпризов.

