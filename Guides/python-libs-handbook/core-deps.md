# 🧱 Основные зависимости проекта: изоляция окружения, фиксация версий и установка пакетов

Эти зависимости помогают создать изолированное рабочее пространство для Python-проекта, зафиксировать версии пакетов и повторяемо устанавливать всё нужное на любой машине. Идея проста: у вас есть свой «песочница-проект», где пакеты не конфликтуют с системными, а версии не пляшут от настроения интернета. Вы создаёте виртуальное окружение, ставите зависимости строго туда, фиксируете их версии и получаете стабильный запуск кода сегодня, завтра и на ноутбуке коллеги.

В этом гайде мы разложим по полочкам базовые инструменты: от стандартных (венв и пип) до современных менеджеров, которые умеют lock-файлы и автоматизируют рутину. Важно: все установки выполняйте только в активированном виртуальном окружении проекта.

## Содержание 🧭

* [venv](#venv) — стандартный модуль для создания виртуальных окружений.
* [pip](#pip) — установщик пакетов и зависимостей в активном окружении.
* [uv](#uv) — быстрый менеджер пакетов и окружений с lock-файлом.
* [pip-tools](#pip-tools) — фиксирует версии и синхронизирует окружение.
* [virtualenv](#virtualenv) — альтернатива venv с дополнительными возможностями.
* [Poetry](#poetry) — менеджер зависимостей через `pyproject.toml` и lock-файл.
* [PDM](#pdm) — современный менеджер зависимостей по актуальным PEP, с lock.
* [Rye](#rye) — единый инструмент: версии Python, зависимости и окружения.
* [Pipenv](#pipenv) — менеджер зависимостей с автоматическим venv и lock.

## venv

**venv** — стандартный модуль Python для создания изолированных виртуальных окружений внутри проекта. Такое окружение хранит свои собственные пакеты и не трогает системный Python. Это помогает запускать код предсказуемо на любой машине.

---

### 🚀 Шаг 1: Создаём виртуальное окружение

В терминале, находясь в корне вашего проекта, выполните команду:

```bash
python -m venv .venv
```

👉 **Что делает команда?** Запускается модуль `venv`, который создаёт новую папку `.venv` со своим интерпретатором Python и директорией для пакетов. Точка перед именем делает папку скрытой в Unix‑системах и помогает держать порядок в корне проекта.

**Ожидаемый результат:** в проекте появится папка `.venv/` со служебными файлами и каталогами (`Scripts` или `bin`, `Lib` и т. п.).

---

### 🔑 Шаг 2: Активируем окружение

Активируйте окружение, чтобы все установки и запуск кода происходили именно внутри `.venv`.

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

👉 Делает текущее окно PowerShell «подключённым» к окружению `.venv`. В начале строки появится префикс `(.venv)`.

**Windows (cmd.exe):**

```bat
.\.venv\Scripts\activate.bat
```

👉 То же самое, но для классической командной строки.

**macOS/Linux (bash/zsh):**

```bash
source .venv/bin/activate
```

👉 Команда `source` исполняет скрипт активации и меняет переменные среды текущего процесса.

**Ожидаемый результат:**

```text
(.venv) yourname@host project-dir $
```

Префикс `(.venv)` указывает, что вы находитесь внутри виртуального окружения.

> Чтобы выйти из окружения в любом терминале:

```bash
deactivate
```

👉 Возвращает терминал к системному Python и его пакетам.

---

### 🛠️ Шаг 3: Обновляем `pip` внутри окружения

Сразу после активации разумно обновить менеджер пакетов:

```bash
python -m pip install --upgrade pip
```

👉 Запускает встроенный модуль `pip` текущего окружения и обновляет его до свежей версии. Это уменьшает шансы на ошибки при установке пакетов.

**Ожидаемый результат:** сообщения об установке/обновлении `pip` и зависимостей (если требуются), завершение без ошибок.

---

### 📦 Шаг 4: Устанавливаем пакеты только внутрь активированного окружения

Для примера установим библиотеку:

```bash
pip install requests
```

👉 Устанавливает пакет `requests` **внутрь** активированного окружения `.venv`. В неактивированном состоянии пакет ушёл бы в системные каталоги, что нам не нужно.

Проверим, что пакет виден из окружения:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Импортирует `requests`, печатает «OK», установленную версию и путь к интерпретатору. Путь должен указывать на `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 📜 Шаг 5: «Импорт» для `venv`

Импорт в коде не требуется. `venv` используется как модуль из командной строки. Полезно знать, как получить помощь по опциям:

```bash
python -m venv --help
```

👉 Показывает краткую справку по аргументам (`--prompt`, `--upgrade-deps` и др.).

---

### 🎉 Результат (что должно получиться?)

Структура проекта после шагов выше может выглядеть так:

```text
project/
├─ .venv/
│  ├─ bin/ (или Scripts/ на Windows)
│  ├─ lib/ (site-packages внутри)
│  └─ ...
├─ requirements.txt  (опционально, если будете фиксировать версии)
└─ your_code.py
```

👉 У вас есть изолированное окружение с собственным Python и пакетами. Все дальнейшие команды `pip install ...` выполняйте **только** после активации окружения, чтобы зависимости устанавливались в `.venv` и проект был воспроизводимым.

## pip

**pip** — штатный установщик пакетов для Python. Работает из активированного интерпретатора и устанавливает зависимости **в текущее виртуальное окружение** проекта. Это гарантирует, что пакеты не смешаются с системными и код запустится предсказуемо.

---

### 🚀 Шаг 1: Проверяем и обновляем `pip` в активированном окружении

```bash
python -m pip --version
```

👉 Показывает версию и путь до исполняемого файла. Убедитесь, что путь указывает на ваш `.venv`.

```bash
python -m pip install --upgrade pip
```

👉 Обновляет `pip` **внутри текущего окружения** до актуальной версии, чтобы установка пакетов проходила стабильнее.

**Ожидаемый результат (пример):**

```text
pip 24.x from /path/to/project/.venv/lib/python... (python 3.x)
Successfully installed pip-24.x
```

---

### 📦 Шаг 2: Устанавливаем пакеты

```bash
python -m pip install requests
```

👉 Устанавливает пакет `requests` в активированное окружение.

```bash
python -m pip install "requests==2.32.3"
```

👉 Ставит **точную** версию. Полезно для воспроизводимости.

```bash
python -m pip install "urllib3>=2.2"
```

👉 Ставит минимально подходящую версию, если вам важна «не ниже чем».

```bash
python -m pip install -r requirements.txt
```

👉 Устанавливает все зависимости из файла `requirements.txt` (каждая строка — пакет и версия).

**Ожидаемый результат:** логи установки без ошибок. Пакеты доступны в проекте.

---

### 🔍 Шаг 3: Проверяем, что пакет поставился в правильное место

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Импортирует пакет, печатает его версию и путь к интерпретатору. Путь должен вести на `.venv` вашего проекта.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 4: Фиксируем версии зависимостей

```bash
python -m pip freeze > requirements.txt
```

👉 Сохраняет **точные** версии всех установленных пакетов в `requirements.txt`, чтобы другой человек мог получить те же версии.

```bash
python -m pip install -r requirements.txt
```

👉 Воссоздаёт окружение с теми же версиями из `requirements.txt`.

> Продвинутый вариант: проверка хешей.

```bash
python -m pip install --require-hashes -r requirements.txt
```

👉 Строгая установка по файлу, где у каждой строки должны быть `--hash=sha256:...`. Это повышает безопасность и детерминизм.

**Пример фрагмента `requirements.txt` для `--require-hashes` (схема):**

```text
requests==2.32.3 \
    --hash=sha256:<hash1> \
    --hash=sha256:<hash2>
```

---

### 🧹 Шаг 5: Обновления, удаление и диагностика

```bash
python -m pip install -U requests
```

👉 Обновляет пакет до последней доступной версии в рамках ограничений зависимостей.

```bash
python -m pip uninstall requests
```

👉 Удаляет пакет из текущего окружения.

```bash
python -m pip list
```

👉 Показывает установленные пакеты и их версии.

```bash
python -m pip show requests
```

👉 Выводит подробности по конкретному пакету: версия, путь установки, зависимости.

```bash
python -m pip check
```

👉 Проверяет, нет ли конфликтов зависимостей в окружении.

```bash
python -m pip cache purge
```

👉 Очищает кэш `pip`, если нужно освободить место или устранить проблемы с повреждёнными файлами.

**Ожидаемый результат:** пакеты ставятся/обновляются, конфликты видны через `pip check`, окружение чистое и воспроизводимое.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/
├─ requirements.txt   # зафиксированный список версий
└─ your_code.py
```

👉 Вы устанавливаете все зависимости **только внутри активированного окружения**, фиксируете версии в `requirements.txt` и можете воссоздать проект на любой машине без сюрпризов.



## uv

**uv** — сверхбыстрый менеджер пакетов и проектов для Python. Он умеет: создавать и использовать виртуальные окружения, фиксировать версии в lock-файле, ставить зависимости молниеносно и даже управлять установленными версиями Python. Главное для нашего проекта: все установки выполняются **только внутри активированного виртуального окружения** или в окружении, которое создаёт сам `uv` в папке проекта.

---

### 🚀 Шаг 1: Проверяем, что `uv` доступен

```bash
uv --version
```

👉 Показывает версию `uv`. Если команды нет, установите `uv` системно согласно официальной инструкции. В рамках проекта предполагаем, что `uv` уже доступен в терминале.

**Ожидаемый результат (пример):**

```text
uv 0.x.y
```

---

### 🔑 Шаг 2: Активируем окружение или создаём новое под проект

Если у вас уже есть окружение `.venv`, просто активируйте его (как описано в разделе `venv`). Все последующие команды `uv` будут работать **внутри активированного окружения**.

Либо создайте окружение через `uv` рядом с проектом:

```bash
uv venv .venv
```

👉 Создаёт виртуальное окружение в папке `.venv`. После этого активируйте его обычным способом:

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

**macOS/Linux:**

```bash
source .venv/bin/activate
```

**Ожидаемый результат:** в приглашении терминала появится префикс `(.venv)`.

---

### 📦 Шаг 3: Быстрая установка пакетов (совместимый режим `pip`)

Работая в активированном окружении, используйте `uv` как ускоренный аналог `pip`:

```bash
uv pip install requests
```

👉 Устанавливает пакет **в текущем активном окружении**.

```bash
uv pip install "requests==2.32.3"
```

👉 Ставит точную версию для воспроизводимости.

```bash
uv pip install -r requirements.txt
```

👉 Устанавливает зависимости из файла со списком версий.

Проверка, что пакет доступен из окружения:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Должно напечатать «OK», версию и путь к интерпретатору из `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 4: Генерируем и используем зафиксированные списки версий

`uv` умеет функции `pip-tools` для детерминированных установок:

```bash
uv pip compile requirements.in -o requirements.txt
```

👉 Разрешает зависимости из `requirements.in` и пишет **зафиксированные** версии в `requirements.txt`.

```bash
uv pip sync requirements.txt
```

👉 Синхронизирует окружение строго под `requirements.txt` (установит недостающие и удалит лишние пакеты).

**Ожидаемый результат:** окружение содержит ровно те версии, что указаны в `requirements.txt`.

---

### 📄 Шаг 5: Работа через `pyproject.toml` и lock-файл проекта

Альтернативный поток — управлять зависимостями проектно, без `requirements.txt`.

Инициализируем проект:

```bash
uv init
```

👉 Создаёт базовый `pyproject.toml` и файлы конфигурации проекта.

Добавляем зависимости и фиксируем их в lock-файле проекта:

```bash
uv add requests==2.32.3
```

👉 Записывает зависимость в `pyproject.toml`, пересчитывает lock и устанавливает пакеты в окружение.

Синхронизируем окружение строго по lock-файлу:

```bash
uv sync --frozen
```

👉 Устанавливает пакеты **только** из lock-файла; команда упадёт, если lock не соответствует `pyproject.toml`.

Смотрим дерево зависимостей:

```bash
uv tree
```

👉 Показывает, какие версии и через что подтянулись.

**Ожидаемый результат:** в проекте рядом с `pyproject.toml` появляется lock-файл (например, `uv.lock`), а окружение соответствует ему.

> Мини-справка: `pyproject.toml` должен содержать ограничение версии Python, например:

```toml
[project]
name = "my_project"
version = "0.1.0"
requires-python = ">=3.12,<3.13"
```

👉 Это помогает `uv` подбирать корректные версии пакетов и интерпретатора.

---

### 🐍 Шаг 6: Управление версиями Python и запуск команд

Устанавливаем нужную версию Python под проект:

```bash
uv python install 3.12
```

👉 Ставит указанную версию интерпретатора, если её нет локально.

Запускаем команды в контексте проекта и окружения:

```bash
uv run python --version
```

👉 Гарантирует, что используется интерпретатор и пакеты из вашего проекта.

```bash
uv run -m pytest
```

👉 Запускает тесты, гарантируя корректное окружение.

---

### 📜 Шаг 7: «Импорт» для `uv`

Импорт в коде не нужен: `uv` — инструмент командной строки. Работает через команды выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                 # виртуальное окружение проекта
├─ pyproject.toml         # метаданные и список зависимостей (вариант с проектным управлением)
├─ uv.lock                # lock-файл с зафиксированными версиями (появится после add/sync)
├─ requirements.in        # исходные требования (вариант с requirements)
├─ requirements.txt       # зафиксированные версии (после compile)
└─ your_code.py
```

👉 У вас воспроизводимое окружение: зависимости фиксируются в lock или в `requirements.txt`, установки проходят быстро и **только** в проектное окружение. Команды `uv` гарантируют одинаковые версии на любой машине.

## pip-tools

**pip-tools** — набор утилит для детерминируемых установок:

* `pip-compile` генерирует **зафиксированный** список версий (`requirements.txt`) из декларативного файла (`requirements.in` или `pyproject.toml`).
* `pip-sync` приводит окружение к этим версиям: установит нужное и удалит лишнее.

Работайте **только в активированном виртуальном окружении** проекта.

---

### 🚀 Шаг 1: Устанавливаем `pip-tools` в окружение

```bash
python -m pip install pip-tools
```

👉 Ставит пакет `pip-tools` в текущее активированное окружение. Появятся команды `pip-compile` и `pip-sync`.

**Ожидаемый результат (пример):**

```text
Successfully installed pip-tools-7.x
```

---

### 📄 Шаг 2: Описываем верхнеуровневые зависимости

Создайте файл `requirements.in` и перечислите **только** то, что вы напрямую используете в коде (без транзитивных зависимостей):

```text
requests==2.32.3
uvicorn>=0.30
```

👉 Это декларативный список «хочу такие пакеты». Версии можно фиксировать строго (`==`) или задавать нижнюю границу (`>=`).

> Альтернатива: можно компилировать из `pyproject.toml`.

---

### 🧮 Шаг 3: Компилируем фиксированные версии

```bash
pip-compile requirements.in -o requirements.txt
```

👉 Разрешает все зависимости и записывает **точные** версии в `requirements.txt`. Этот файл стабильный и переносимый.

Полезные варианты:

```bash
pip-compile --upgrade -o requirements.txt requirements.in
```

👉 Обновляет все версии до последних совместимых.

```bash
pip-compile --upgrade-package requests -o requirements.txt requirements.in
```

👉 Точечно обновляет один пакет (и его дерево зависимостей).

```bash
pip-compile --generate-hashes -o requirements.txt requirements.in
```

👉 Добавляет криптохеши для каждой колёсной сборки/архива. Повышает безопасность и детерминизм.

**Ожидаемый результат (фрагмент):**

```text
# This file is autogenerated by pip-compile
requests==2.32.3 \
    --hash=sha256:<hash1> \
    --hash=sha256:<hash2>
urllib3==2.2.3 \
    --hash=sha256:<hashA> \
    --hash=sha256:<hashB>
```

---

### 🔁 Шаг 4: Синхронизируем окружение по зафиксированным версиям

```bash
pip-sync requirements.txt
```

👉 Приводит окружение **строго** к `requirements.txt`: установит недостающие версии и удалит пакеты, которых в файле нет.

Осторожный режим:

```bash
pip-sync --dry-run requirements.txt
```

👉 Покажет план изменений без выполнения.

**Ожидаемый результат:** вывод с установкой/удалением, после чего `pip list` совпадает с `requirements.txt`.

---

### 🧪 Шаг 5: Проверяем, что пакеты ставятся из окружения

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Печатает версию `requests` и путь к интерпретатору. Путь должен указывать на `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧰 Шаг 6: Дополнительно — работа с `pyproject.toml`

Если вы храните зависимости в `pyproject.toml`, можно компилировать прямо из него:

```bash
pip-compile -o requirements.txt pyproject.toml
```

👉 Считывает раздел с зависимостями проекта и формирует фиксированный `requirements.txt`.

Экстры (если используются):

```bash
pip-compile -o requirements-dev.txt --extra dev pyproject.toml
```

👉 Собирает зависимости для дополнительного профиля, например `dev`.

---

### 🎯 Результат (что должно получиться?)

```text
project/
├─ .venv/
├─ requirements.in        # декларативный список верхнеуровневых зависимостей
├─ requirements.txt       # зафиксированный, переносимый список версий (с хешами, если включили)
├─ pyproject.toml         # опционально: источник зависимостей для compile
└─ your_code.py
```

👉 Проект воспроизводим: версии фиксируются `pip-compile`, окружение синхронизируется `pip-sync`. Устанавливайте и обновляйте зависимости предсказуемо на любой машине.

## virtualenv

**virtualenv** — продвинутая утилита для создания виртуальных окружений. По сравнению с `venv` она гибче и обычно быстрее, особенно если нужна **нестандартная версия Python** или тонкая настройка. Все установки выполняйте **только в активированном окружении проекта**.

---

### 🚦 Шаг 1: Проверяем, что `virtualenv` доступен

```bash
virtualenv --version
```

👉 Показывает версию утилиты. Если команда не найдена, установите `virtualenv` заранее (в рамках гайда считаем, что она уже доступна в системе).

**Ожидаемый результат (пример):**

```text
virtualenv 20.x.y from ...
```

---

### 🏗️ Шаг 2: Создаём окружение рядом с проектом

Быстрый старт (интерпретатор по умолчанию):

```bash
virtualenv .venv
```

👉 Создаёт папку `.venv` со своим Python и `pip`. По умолчанию используются симлинки, что ускоряет работу.

Создание с обновлением «посевных» инструментов:

```bash
virtualenv .venv --upgrade-deps
```

👉 Сразу подтягивает свежие версии `pip`, `setuptools`, `wheel` внутри окружения.

Задаём человекочитаемый префикс в приглашении:

```bash
virtualenv .venv --prompt "proj"
```

👉 После активации в начале строки будет `(proj)` вместо `(.venv)` — удобно, когда окружений много.

**Ожидаемый результат:** в проекте появляется каталог `.venv/` (`bin/` на macOS/Linux или `Scripts/` на Windows, плюс `lib/` с пакетами).

---

### 🔢 Шаг 3: Выбираем конкретную версию Python

Если нужен другой Python (например, 3.12), укажите путь или используйте лаунчер:

**macOS/Linux (через путь):**

```bash
virtualenv -p /usr/bin/python3.12 .venv312
```

👉 Берёт интерпретатор по указанному пути и создаёт окружение `.venv312`.

**Кроссплатформенно (если доступен нужный интерпретатор в PATH):**

```bash
virtualenv -p python3.12 .venv312
```

👉 Попросит системный PATH выдать `python3.12` и соберёт окружение на этой версии.

**Windows (с лаунчером py):**

```bat
py -3.11 -m virtualenv .venv311
```

👉 Запускает модуль `virtualenv` под Python 3.11 и создаёт окружение `.venv311`.

**Ожидаемый результат:** отдельные папки окружений для нужных версий: `.venv312/`, `.venv311/` и т. д.

---

### 🔑 Шаг 4: Активируем окружение

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

**Windows (cmd.exe):**

```bat
.\.venv\Scripts\activate.bat
```

**macOS/Linux:**

```bash
source .venv/bin/activate
```

👉 Скрипт активации меняет переменные среды текущего процесса. В приглашении появится префикс окружения.

**Ожидаемый результат (пример):**

```text
(.venv) user@host project $
```

Чтобы выйти:

```bash
deactivate
```

👉 Возвращает терминал к системному Python.

---

### 🧰 Шаг 5: Устанавливаем и проверяем пакеты внутри окружения

Сначала обновим `pip` именно в этом окружении:

```bash
python -m pip install --upgrade pip
```

👉 Меньше сюрпризов при установке библиотек.

Устанавливаем зависимости **только после активации**:

```bash
pip install requests
```

👉 Ставит пакет в `.venv`.

Проверка, что всё в нужном месте:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Должно вывести «OK», версию и путь к интерпретатору из `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🔁 Шаг 6: Воспроизводим окружение на другой машине

Сохраняем точные версии в файл:

```bash
python -m pip freeze > requirements.txt
```

👉 Фиксирует полный снимок окружения.

Воссоздаём окружение из файла на другой машине:

```bash
virtualenv .venv
source .venv/bin/activate   # или эквивалент для Windows
python -m pip install -r requirements.txt
```

👉 Получаем те же версии пакетов и предсказуемый запуск кода.

---

### 🔧 Шаг 7: Полезные параметры настройки

Копии вместо симлинков (актуально для сетевых дисков/контейнеров):

```bash
virtualenv .venv --copies
```

👉 Использует физические копии файлов Python, когда симлинки нежелательны.

Чистая пересборка окружения в той же папке:

```bash
rm -rf .venv && virtualenv .venv --upgrade-deps
```

👉 Полное пере‑создание окружения с обновлёнными инструментами.

---

### 📜 «Импорт» для `virtualenv`

Импорта в коде нет — это CLI‑утилита. Вся работа выполняется командами выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                 # виртуальное окружение проекта (или .venv311, .venv312 и т. п.)
├─ requirements.txt       # зафиксированные версии (если используете freeze)
└─ your_code.py
```

👉 У вас изолированное и при необходимости многоверсионное окружение. Все пакеты ставятся внутрь `.venv`, а проект воспроизводится на любой машине.

## Poetry

**Poetry** — менеджер зависимостей и виртуальных окружений, который хранит список пакетов в `pyproject.toml` и фиксирует версии в `poetry.lock`. Он автоматизирует установку, обновления и запуск команд так, чтобы проект собирался одинаково на любой машине.

> В нашем проекте все инструменты устанавливаются **внутрь виртуального окружения**. Поэтому сначала активируйте `.venv`, а затем ставьте `poetry` в это окружение.

---

### 🚀 Шаг 1: Устанавливаем и проверяем Poetry

```bash
python -m pip install --upgrade pip
python -m pip install poetry
poetry --version
```

👉 Обновляем `pip`, устанавливаем `Poetry` в текущее окружение и проверяем, что команда доступна. Версия должна отобразиться без ошибок.

**Ожидаемый результат (пример):**

```text
Poetry (version 1.8.x)
```

---

### 🧭 Шаг 2: Настраиваем хранение окружения в папке проекта

```bash
poetry config virtualenvs.create true
poetry config virtualenvs.in-project true
poetry config virtualenvs.prefer-active-python true
```

👉 Говорим Poetry всегда создавать виртуальное окружение и хранить его **внутри проекта** в папке `.venv`. Параметр `prefer-active-python` заставляет Poetry использовать активный интерпретатор, что уменьшает «магии» и сюрпризов.

**Ожидаемый результат:**

```text
Setting virtualenvs.create to true
Setting virtualenvs.in-project to true
Setting virtualenvs.prefer-active-python to true
```

---

### 🏗️ Шаг 3: Инициализируем проект (создаём `pyproject.toml`)

```bash
poetry init
```

👉 Откроется простой опрос: имя проекта, версия Python и зависимости. Можно нажать Enter, чтобы принять значения по умолчанию, и добавить зависимости позже.

Не хотите опрос? Минимальная неинтерактивная инициализация:

```bash
poetry init -n
```

👉 Создаст базовый `pyproject.toml` без вопросов.

**Ожидаемый результат:** в корне проекта появляется `pyproject.toml` с разделом `[tool.poetry]` и ограничением версии Python, например:

```toml
[tool.poetry]
name = "my_project"
version = "0.1.0"

[tool.poetry.dependencies]
python = ">=3.12,<3.13"
```

---

### 🐍 Шаг 4: Выбираем версию Python для окружения

```bash
poetry env use 3.12
```

👉 Указывает Poetry, какой интерпретатор использовать. Он найдёт `python3.12` в системе и привяжет окружение к этой версии. Альтернатива — прописать диапазон в `pyproject.toml` (см. выше).

Проверим информацию об окружении:

```bash
poetry env info
```

👉 Покажет путь к `.venv` и версию Python.

---

### 📦 Шаг 5: Добавляем зависимости (и dev‑зависимости)

```bash
poetry add requests==2.32.3
```

👉 Добавляет пакет в раздел зависимостей, пересчитывает `poetry.lock` и устанавливает в окружение.

```bash
poetry add --group dev pytest
```

👉 Добавляет пакет в группу `dev` (аналог «для разработки»). Группы удобно включать/исключать при установке.

```bash
poetry add "urllib3>=2.2"
```

👉 Фиксирует нижнюю границу версии. Точные версии повышают предсказуемость, границы — гибкость.

**Ожидаемый результат:** обновлены `pyproject.toml` и `poetry.lock`, пакеты установлены в `.venv`.

---

### 🔒 Шаг 6: Фиксируем и синхронизируем версии

```bash
poetry lock
```

👉 Пересчитывает `poetry.lock` согласно `pyproject.toml`, фиксируя **конкретные** версии всех транзитивных зависимостей.

```bash
poetry install --sync
```

👉 Устанавливает ровно то, что в lock‑файле, и удаляет лишнее. Это гарантирует одинаковое окружение у всей команды.

Обновление до последних совместимых версий:

```bash
poetry update
```

👉 Пересобирает lock, поднимая версии в рамках ограничений.

---

### 🧪 Шаг 7: Запускаем команды в правильном окружении

```bash
poetry run python --version
poetry run -m pytest -q
```

👉 `poetry run` выполняет команду в контексте проектного окружения. Так вы точно используете верные пакеты и интерпретатор.

Интерактивная оболочка окружения:

```bash
poetry shell
```

👉 Откроет подсессию с активированным `.venv` и префиксом `(my_project-py3.12)`.

---

### 🧾 Шаг 8: Экспорт в `requirements.txt` (если нужен)

```bash
poetry export -f requirements.txt -o requirements.txt --with-hashes
```

👉 Генерирует `requirements.txt` из lock‑файла с криптохешами. Полезно, если инфраструктура ожидает `pip install -r requirements.txt`.

Экспорт без хешей и без dev‑зависимостей:

```bash
poetry export -f requirements.txt -o requirements.txt --without-hashes --without dev
```

👉 Получите минимальный продакшен‑набор.

---

### 🔁 Шаг 9: Клонируем проект и воссоздаём окружение на другой машине

```bash
git clone <repo-url> my_project
cd my_project
python -m pip install poetry
poetry install --sync --no-root
```

👉 Устанавливаем Poetry в локальное `.venv` и воссоздаём окружение строго по `poetry.lock`. Флаг `--no-root` пропускает установку самого проекта как пакета, если это не требуется.

Проверка, что пакеты доступны из окружения:

```bash
poetry run python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Должно вывести «OK», версию и путь к Python внутри `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧹 Шаг 10: Удаляем или меняем зависимости

```bash
poetry remove requests
```

👉 Удаляет пакет, обновляя `pyproject.toml` и `poetry.lock`.

Точечное обновление пакета:

```bash
poetry update requests
```

👉 Поднимает версию `requests` и связанные зависимости в lock‑файле.

---

### 📜 «Импорт» для Poetry

Импорта в коде нет — это CLI‑инструмент. Всё управление выполняется командами выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                # виртуальное окружение проекта (благодаря настройке in-project)
├─ pyproject.toml        # декларативный список зависимостей и метаданных
├─ poetry.lock           # lock-файл с точными версиями
└─ your_code.py
```

👉 У вас воспроизводимое окружение: зависимости описаны в `pyproject.toml`, версии зафиксированы в `poetry.lock`, а команды `poetry install --sync` и `poetry run ...` гарантируют одинаковый результат на любой машине.

## PDM

**PDM** — современный менеджер зависимостей, следующий актуальным PEP. Хранит список пакетов в `pyproject.toml`, фиксирует версии в `pdm.lock`, автоматически создаёт и использует изолированное окружение для проекта и запускает команды в нём. Цель — воспроизводимые установки и одинаковый запуск кода на любой машине.

> В рамках этого репозитория инструменты ставим **внутрь виртуального окружения** проекта. Активируйте `.venv`, затем установите PDM в него.

---

### 🚀 Шаг 1: Устанавливаем и проверяем PDM

```bash
python -m pip install --upgrade pip
python -m pip install pdm
pdm --version
```

👉 Обновляем `pip`, ставим PDM в активированное окружение и проверяем доступность. Если версия показалась — всё ок.

**Ожидаемый результат (пример):**

```text
PDM, version 2.x.y
```

---

### 🏗️ Шаг 2: Инициализируем проект (создаём `pyproject.toml`)

```bash
pdm init
```

👉 Небольшой опрос поможет создать `pyproject.toml`: название проекта, версия Python, начальные зависимости. Можно принять значения по умолчанию и добавить пакеты позже.

Без опроса:

```bash
pdm init -n
```

👉 Создаёт минимальный `pyproject.toml` сразу.

**Ожидаемый результат (фрагмент):**

```toml
[project]
name = "my_project"
version = "0.1.0"
requires-python = ">=3.12,<3.13"
```

👉 Ограничение `requires-python` помогает PDM подбирать совместимые версии.

---

### 🐍 Шаг 3: Выбираем интерпретатор Python для проекта

```bash
pdm use -f 3.12
```

👉 Привязывает проект к Python 3.12, если он установлен в системе. Можно указать полный путь:

```bash
pdm use -f /usr/bin/python3.12
```

👉 PDM запомнит выбранный интерпретатор и будет создавать для проекта соответствующее окружение.

Проверим сведения об окружении:

```bash
pdm info
```

👉 Покажет активный Python и путь до проектного окружения.

---

### 📦 Шаг 4: Добавляем зависимости (включая dev‑группы)

```bash
pdm add requests==2.32.3
```

👉 Добавляет пакет в `pyproject.toml`, пересчитывает `pdm.lock` и устанавливает его в проектное окружение.

```bash
pdm add --group dev pytest
```

👉 Создаёт группу `dev` и добавляет туда `pytest`. Удобно разделять зависимости «для разработки» и «для продакшена».

```bash
pdm add "urllib3>=2.2"
```

👉 Фиксирует нижнюю границу версии. Жёсткие версии дают максимальную предсказуемость, границы — гибкость.

**Ожидаемый результат:** обновились `pyproject.toml` и `pdm.lock`, пакеты установлены в окружение проекта.

---

### 🔒 Шаг 5: Фиксируем и синхронизируем версии

```bash
pdm lock
```

👉 Пересчитывает `pdm.lock` согласно текущему `pyproject.toml` и фиксирует точные версии всех транзитивных зависимостей.

```bash
pdm install
```

👉 Устанавливает зависимости из `pdm.lock`. Если lock актуален, версии пакетов будут ровно теми, что зафиксированы.

Обновляем до последних совместимых версий:

```bash
pdm update
```

👉 Пересобирает lock-файл в рамках ограничений версий и синхронизирует окружение.

---

### 🧪 Шаг 6: Запускаем команды в правильном окружении

```bash
pdm run python --version
pdm run -m pytest -q
```

👉 `pdm run` гарантирует, что команда выполняется в контексте проектного окружения и использует нужные пакеты.

Проверка доступности установленного пакета:

```bash
pdm run python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 7: Экспорт в `requirements.txt` (если нужен)

```bash
pdm export -f requirements -o requirements.txt
```

👉 Генерирует переносимый список версий, совместимый с `pip install -r requirements.txt`. Можно экспортировать только продакшен-зависимости:

```bash
pdm export -f requirements -o requirements.txt --prod
```

👉 Исключает группы разработки.

---

### 🔁 Шаг 8: Клонируем проект и воссоздаём окружение на другой машине

```bash
git clone <repo-url> my_project
cd my_project
python -m pip install pdm
pdm install
```

👉 Устанавливаем PDM в локальное окружение и воссоздаём проект строго по `pdm.lock`.

Проверка:

```bash
pdm run python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Должно вывести «OK», версию и путь к Python внутри проектного окружения.

---

### 🧹 Шаг 9: Обслуживание зависимостей

```bash
pdm remove requests
```

👉 Удаляет пакет из `pyproject.toml`, обновляет lock и синхронизирует окружение.

```bash
pdm update requests
```

👉 Точечно поднимает версию выбранного пакета и перестраивает lock.

Список установленных пакетов:

```bash
pdm list
```

👉 Краткий обзор установленных версий в проектном окружении.

---

### 📜 «Импорт» для PDM

Импорт в коде не требуется — PDM это инструмент командной строки, вся работа выполняется командами выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                # виртуальное окружение проекта (используется PDM при запуске команд)
├─ pyproject.toml        # декларативный список зависимостей и метаданных
├─ pdm.lock              # lock-файл с точными версиями
└─ your_code.py
```

👉 Проект воспроизводим: зависимости описаны в `pyproject.toml`, зафиксированы в `pdm.lock`, команды `pdm install` и `pdm run ...` обеспечивают одинаковый результат на любой машине.

## Rye

**Rye** — единый инструмент для Python, который управляет версиями интерпретатора, зависимостями и виртуальными окружениями. Хранит зависимости в `pyproject.toml`, фиксирует их в lock‑файле (например, `requirements.lock`) и синхронизирует окружение так, чтобы проект собирался одинаково на любой машине.

> В этом репозитории мы ставим инструменты **внутрь виртуального окружения проекта**. Активируйте `.venv`, затем установите Rye в него.

---

### 🚀 Шаг 1: Устанавливаем и проверяем Rye

```bash
python -m pip install --upgrade pip
python -m pip install rye
rye --version
```

👉 Обновляем `pip`, ставим Rye в активированное окружение и проверяем, что команда доступна.

**Ожидаемый результат (пример):**

```text
rye 0.x.y
```

---

### 🏗️ Шаг 2: Инициализируем проект

```bash
rye init
```

👉 Создаёт `pyproject.toml`, базовую структуру настройки проекта и подготовит конфигурацию для последующей синхронизации зависимостей.

Не хотите опрос? Минимальная инициализация без вопросов:

```bash
rye init --no-interaction
```

👉 Создаёт базовый `pyproject.toml` сразу.

**Ожидаемый результат:** в корне проекта появляется `pyproject.toml` с основными метаданными и разделами для зависимостей.

---

### 🐍 Шаг 3: Выбираем версию Python

```bash
rye pin 3.12
```

👉 «Прикрепляет» проект к Python 3.12, чтобы все участники команды использовали одинаковый интерпретатор.

Проверить доступные интерпретаторы:

```bash
rye toolchain list
```

👉 Показывает установленные версии Python, которые Rye может использовать.

Если нужной версии нет, установите её:

```bash
rye toolchain install 3.12
```

👉 Скачает/подготовит требуемый интерпретатор под проект.

---

### 🔑 Шаг 4: Создаём и синхронизируем окружение

```bash
rye sync
```

👉 Создаёт виртуальное окружение проекта (обычно `.venv`) и устанавливает зависимости согласно lock‑файлу. Если lock отсутствует, он будет сгенерирован на основе `pyproject.toml`.

Строгий режим без изменений lock‑файла:

```bash
rye sync --frozen
```

👉 Устанавливает **строго** по lock‑файлу и завершится с ошибкой, если lock не соответствует `pyproject.toml`.

**Ожидаемый результат:** создано `.venv/`, зависимости установлены без конфликтов.

---

### 📦 Шаг 5: Добавляем зависимости

```bash
rye add requests==2.32.3
```

👉 Записывает зависимость в `pyproject.toml`, пересчитывает lock и устанавливает её в окружение.

Зависимость «для разработки»:

```bash
rye add --dev pytest
```

👉 Добавит пакет в dev‑группу, чтобы его можно было исключить при продакшен‑сборке.

Обновляем lock‑файл явно (при необходимости):

```bash
rye lock
```

👉 Пересобирает lock без установки, если вы хотите только обновить фиксации.

---

### 🧪 Шаг 6: Запускаем команды в правильном окружении

```bash
rye run python --version
rye run -m pytest -q
```

👉 `rye run` выполняет команды внутри проектного окружения, гарантируя использование нужного интерпретатора и пакетов.

Проверка установленного пакета и пути к интерпретатору:

```bash
rye run python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🔁 Шаг 7: Клонируем проект и воссоздаём окружение на другой машине

```bash
git clone <repo-url> my_project
cd my_project
python -m pip install rye
rye sync --frozen
```

👉 Устанавливаем Rye в локальное окружение и воссоздаём зависимости **строго** по lock‑файлу.

---

### 🧹 Шаг 8: Обслуживание зависимостей

Удалить пакет:

```bash
rye remove requests
```

👉 Удаляет зависимость из `pyproject.toml`, обновляет lock и синхронизирует окружение при следующем `rye sync`.

Поднять версии до последних совместимых:

```bash
rye lock --update
rye sync
```

👉 Обновляет фиксации и приводит окружение к ним.

---

### 📜 «Импорт» для Rye

Импорт в коде не требуется — Rye это CLI‑инструмент. Все операции выполняются командами выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                # виртуальное окружение проекта
├─ pyproject.toml        # декларативный список зависимостей
├─ requirements.lock     # lock‑файл с точными версиями (создаётся/обновляется Rye)
└─ your_code.py
```

👉 Проект воспроизводим: версии Python и пакетов зафиксированы, `rye sync` обеспечивает одинаковую установку на любой машине.

## Pipenv

**Pipenv** — менеджер зависимостей с автоматическим созданием виртуального окружения и lock‑файлом `Pipfile.lock`. Хранит список пакетов в `Pipfile`, фиксирует точные версии в `Pipfile.lock` и запускает команды внутри окружения проекта.

> В этом репозитории инструменты ставим **внутрь виртуального окружения** проекта. Активируйте `.venv`, затем установите Pipenv в него. Чтобы окружение проекта хранилось рядом с кодом, включим режим `.venv` в корне проекта.

---

### 🚀 Шаг 1: Устанавливаем и проверяем Pipenv

```bash
python -m pip install --upgrade pip
python -m pip install pipenv
pipenv --version
```

👉 Обновляем `pip`, устанавливаем Pipenv в активированное окружение и проверяем, что команда доступна.

**Ожидаемый результат (пример):**

```text
pipenv, version 2024.x.y
```

---

### 📍 Шаг 2: Включаем хранение окружения прямо в проекте

**macOS/Linux:**

```bash
export PIPENV_VENV_IN_PROJECT=1
```

**Windows (PowerShell):**

```powershell
$env:PIPENV_VENV_IN_PROJECT = 1
```

**Windows (cmd.exe):**

```bat
set PIPENV_VENV_IN_PROJECT=1
```

👉 Настраивает Pipenv создавать виртуальное окружение в папке `.venv` внутри текущего проекта. Так проще контролировать и переносить окружение.

Проверим, где находится окружение (после создания):

```bash
pipenv --venv
```

👉 Должен вернуть путь вида `/path/to/project/.venv`.

---

### 🏗️ Шаг 3: Инициализируем проект и выбираем Python

```bash
pipenv --python 3.12
```

👉 Создаёт `Pipfile`, подбирает интерпретатор Python 3.12 и формирует виртуальное окружение проекта в `.venv`.

**Ожидаемый результат:** создан `Pipfile` с секцией `[packages]` и указанием версии Python, окружение в `.venv/`.

---

### 📦 Шаг 4: Добавляем зависимости (включая dev‑набор)

```bash
pipenv add requests==2.32.3
```

👉 Добавляет пакет в `Pipfile`, устанавливает его в окружение и записывает точную версию в `Pipfile.lock`.

```bash
pipenv add --dev pytest
```

👉 Добавляет пакет в раздел разработчика (`[dev-packages]`), чтобы его можно было исключить в продакшене.

```bash
pipenv add "urllib3>=2.2"
```

👉 Устанавливает минимально допустимую версию с возможностью обновлений в рамках ограничения.

**Ожидаемый результат:** обновлены `Pipfile` и `Pipfile.lock`, пакеты доступны в проектном окружении.

---

### 🔒 Шаг 5: Фиксация и синхронизация окружения

```bash
pipenv lock
```

👉 Пересчитывает `Pipfile.lock`, фиксируя **конкретные** версии всех транзитивных зависимостей.

```bash
pipenv sync
```

👉 Приводит окружение **строго** к `Pipfile.lock`: установит недостающее и удалит лишнее.

Продакшен‑режим (без dev):

```bash
pipenv sync --categories main
```

👉 Устанавливает только боевые зависимости из `Pipfile.lock`.

**Ожидаемый результат:** пакеты в окружении соответствуют lock‑файлу.

---

### 🧪 Шаг 6: Запуск команд внутри окружения

```bash
pipenv run python --version
pipenv run -m pytest -q
```

👉 `pipenv run` гарантирует, что команды выполняются с тем Python и пакетами, что принадлежат проекту.

Интерактивная оболочка окружения:

```bash
pipenv shell
```

👉 Откроет подсессию с активированным `.venv` и префиксом `(.venv)` в приглашении.

Проверка доступности установленного пакета:

```bash
pipenv run python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 7: Экспорт в `requirements.txt` (если требуется инфраструктурой)

```bash
pipenv lock -r > requirements.txt
pipenv lock -r --dev > requirements-dev.txt
```

👉 Генерирует списки версий, совместимые с `pip install -r ...`. Полезно для CI/CD, где ожидается формат `requirements.txt`.

---

### 🔁 Шаг 8: Клонируем проект и воссоздаём окружение на другой машине

```bash
git clone <repo-url> my_project
cd my_project
python -m pip install pipenv
# включаем .venv в проекте
export PIPENV_VENV_IN_PROJECT=1   # или эквивалент для Windows
pipenv sync --dev --deploy
```

👉 Устанавливаем Pipenv, принудительно используем lock‑файл (`--deploy`) и восстанавливаем окружение с dev‑пакетами (`--dev`). Для продакшена опустите `--dev`.

---

### 🧹 Шаг 9: Обслуживание зависимостей

Удаление пакета:

```bash
pipenv uninstall requests
```

👉 Удаляет пакет, обновляет `Pipfile` и `Pipfile.lock`.

Обновления до последних совместимых версий:

```bash
pipenv update
```

👉 Пересобирает lock‑файл и обновляет окружение согласно новым фиксациям.

Анализ дерева зависимостей и уязвимостей:

```bash
pipenv graph
pipenv check
```

👉 `graph` показывает структуру зависимостей, `check` проверяет известные проблемы безопасности.

---

### 📜 «Импорт» для Pipenv

Импорт в коде не требуется — Pipenv это CLI‑инструмент. Вся работа выполняется командами выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/            # виртуальное окружение проекта (благодаря PIPENV_VENV_IN_PROJECT)
├─ Pipfile           # декларативный список зависимостей
├─ Pipfile.lock      # lock‑файл с зафиксированными версиями
└─ your_code.py
```

👉 Проект воспроизводим: зависимости описаны в `Pipfile`, зафиксированы в `Pipfile.lock`, а `pipenv sync` и `pipenv run` обеспечивают одинаковую установку и запуск на любой машине.

