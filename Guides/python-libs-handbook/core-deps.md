# 🧱 Основные зависимости проекта: изоляция окружения, фиксация версий и установка пакетов

Эти зависимости помогают создать изолированное рабочее пространство для Python-проекта, зафиксировать версии пакетов и повторяемо устанавливать всё нужное на любой машине. Идея проста: у вас есть свой «песочница-проект», где пакеты не конфликтуют с системными, а версии не пляшут от настроения интернета. Вы создаёте виртуальное окружение, ставите зависимости строго туда, фиксируете их версии и получаете стабильный запуск кода сегодня, завтра и на ноутбуке коллеги.

В этом гайде мы разложим по полочкам базовые инструменты: от стандартных (венв и пип) до современных менеджеров, которые умеют lock-файлы и автоматизируют рутину. Важно: все установки выполняйте только в активированном виртуальном окружении проекта.

## Содержание 🧭

* [venv](#venv) — стандартный модуль для создания виртуальных окружений.
* [pip](#pip) — установщик пакетов и зависимостей в активном окружении.
* [uv](#uv) — быстрый менеджер пакетов и окружений с lock-файлом.
* [pip-tools](#pip-tools) — фиксирует версии и синхронизирует окружение.
* [virtualenv](#virtualenv) — альтернатива venv с дополнительными возможностями.
* [Poetry](#poetry) — менеджер зависимостей через `pyproject.toml` и lock-файл.
* [PDM](#pdm) — современный менеджер зависимостей по актуальным PEP, с lock.
* [Rye](#rye) — единый инструмент: версии Python, зависимости и окружения.
* [Pipenv](#pipenv) — менеджер зависимостей с автоматическим venv и lock.

## venv

**venv** — стандартный модуль Python для создания изолированных виртуальных окружений внутри проекта. Такое окружение хранит свои собственные пакеты и не трогает системный Python. Это помогает запускать код предсказуемо на любой машине.

---

### 🚀 Шаг 1: Создаём виртуальное окружение

В терминале, находясь в корне вашего проекта, выполните команду:

```bash
python -m venv .venv
```

👉 **Что делает команда?** Запускается модуль `venv`, который создаёт новую папку `.venv` со своим интерпретатором Python и директорией для пакетов. Точка перед именем делает папку скрытой в Unix‑системах и помогает держать порядок в корне проекта.

**Ожидаемый результат:** в проекте появится папка `.venv/` со служебными файлами и каталогами (`Scripts` или `bin`, `Lib` и т. п.).

---

### 🔑 Шаг 2: Активируем окружение

Активируйте окружение, чтобы все установки и запуск кода происходили именно внутри `.venv`.

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

👉 Делает текущее окно PowerShell «подключённым» к окружению `.venv`. В начале строки появится префикс `(.venv)`.

**Windows (cmd.exe):**

```bat
.\.venv\Scripts\activate.bat
```

👉 То же самое, но для классической командной строки.

**macOS/Linux (bash/zsh):**

```bash
source .venv/bin/activate
```

👉 Команда `source` исполняет скрипт активации и меняет переменные среды текущего процесса.

**Ожидаемый результат:**

```text
(.venv) yourname@host project-dir $
```

Префикс `(.venv)` указывает, что вы находитесь внутри виртуального окружения.

> Чтобы выйти из окружения в любом терминале:

```bash
deactivate
```

👉 Возвращает терминал к системному Python и его пакетам.

---

### 🛠️ Шаг 3: Обновляем `pip` внутри окружения

Сразу после активации разумно обновить менеджер пакетов:

```bash
python -m pip install --upgrade pip
```

👉 Запускает встроенный модуль `pip` текущего окружения и обновляет его до свежей версии. Это уменьшает шансы на ошибки при установке пакетов.

**Ожидаемый результат:** сообщения об установке/обновлении `pip` и зависимостей (если требуются), завершение без ошибок.

---

### 📦 Шаг 4: Устанавливаем пакеты только внутрь активированного окружения

Для примера установим библиотеку:

```bash
pip install requests
```

👉 Устанавливает пакет `requests` **внутрь** активированного окружения `.venv`. В неактивированном состоянии пакет ушёл бы в системные каталоги, что нам не нужно.

Проверим, что пакет виден из окружения:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Импортирует `requests`, печатает «OK», установленную версию и путь к интерпретатору. Путь должен указывать на `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 📜 Шаг 5: «Импорт» для `venv`

Импорт в коде не требуется. `venv` используется как модуль из командной строки. Полезно знать, как получить помощь по опциям:

```bash
python -m venv --help
```

👉 Показывает краткую справку по аргументам (`--prompt`, `--upgrade-deps` и др.).

---

### 🎉 Результат (что должно получиться?)

Структура проекта после шагов выше может выглядеть так:

```text
project/
├─ .venv/
│  ├─ bin/ (или Scripts/ на Windows)
│  ├─ lib/ (site-packages внутри)
│  └─ ...
├─ requirements.txt  (опционально, если будете фиксировать версии)
└─ your_code.py
```

👉 У вас есть изолированное окружение с собственным Python и пакетами. Все дальнейшие команды `pip install ...` выполняйте **только** после активации окружения, чтобы зависимости устанавливались в `.venv` и проект был воспроизводимым.

## pip

**pip** — штатный установщик пакетов для Python. Работает из активированного интерпретатора и устанавливает зависимости **в текущее виртуальное окружение** проекта. Это гарантирует, что пакеты не смешаются с системными и код запустится предсказуемо.

---

### 🚀 Шаг 1: Проверяем и обновляем `pip` в активированном окружении

```bash
python -m pip --version
```

👉 Показывает версию и путь до исполняемого файла. Убедитесь, что путь указывает на ваш `.venv`.

```bash
python -m pip install --upgrade pip
```

👉 Обновляет `pip` **внутри текущего окружения** до актуальной версии, чтобы установка пакетов проходила стабильнее.

**Ожидаемый результат (пример):**

```text
pip 24.x from /path/to/project/.venv/lib/python... (python 3.x)
Successfully installed pip-24.x
```

---

### 📦 Шаг 2: Устанавливаем пакеты

```bash
python -m pip install requests
```

👉 Устанавливает пакет `requests` в активированное окружение.

```bash
python -m pip install "requests==2.32.3"
```

👉 Ставит **точную** версию. Полезно для воспроизводимости.

```bash
python -m pip install "urllib3>=2.2"
```

👉 Ставит минимально подходящую версию, если вам важна «не ниже чем».

```bash
python -m pip install -r requirements.txt
```

👉 Устанавливает все зависимости из файла `requirements.txt` (каждая строка — пакет и версия).

**Ожидаемый результат:** логи установки без ошибок. Пакеты доступны в проекте.

---

### 🔍 Шаг 3: Проверяем, что пакет поставился в правильное место

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Импортирует пакет, печатает его версию и путь к интерпретатору. Путь должен вести на `.venv` вашего проекта.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 4: Фиксируем версии зависимостей

```bash
python -m pip freeze > requirements.txt
```

👉 Сохраняет **точные** версии всех установленных пакетов в `requirements.txt`, чтобы другой человек мог получить те же версии.

```bash
python -m pip install -r requirements.txt
```

👉 Воссоздаёт окружение с теми же версиями из `requirements.txt`.

> Продвинутый вариант: проверка хешей.

```bash
python -m pip install --require-hashes -r requirements.txt
```

👉 Строгая установка по файлу, где у каждой строки должны быть `--hash=sha256:...`. Это повышает безопасность и детерминизм.

**Пример фрагмента `requirements.txt` для `--require-hashes` (схема):**

```text
requests==2.32.3 \
    --hash=sha256:<hash1> \
    --hash=sha256:<hash2>
```

---

### 🧹 Шаг 5: Обновления, удаление и диагностика

```bash
python -m pip install -U requests
```

👉 Обновляет пакет до последней доступной версии в рамках ограничений зависимостей.

```bash
python -m pip uninstall requests
```

👉 Удаляет пакет из текущего окружения.

```bash
python -m pip list
```

👉 Показывает установленные пакеты и их версии.

```bash
python -m pip show requests
```

👉 Выводит подробности по конкретному пакету: версия, путь установки, зависимости.

```bash
python -m pip check
```

👉 Проверяет, нет ли конфликтов зависимостей в окружении.

```bash
python -m pip cache purge
```

👉 Очищает кэш `pip`, если нужно освободить место или устранить проблемы с повреждёнными файлами.

**Ожидаемый результат:** пакеты ставятся/обновляются, конфликты видны через `pip check`, окружение чистое и воспроизводимое.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/
├─ requirements.txt   # зафиксированный список версий
└─ your_code.py
```

👉 Вы устанавливаете все зависимости **только внутри активированного окружения**, фиксируете версии в `requirements.txt` и можете воссоздать проект на любой машине без сюрпризов.



## uv

**uv** — сверхбыстрый менеджер пакетов и проектов для Python. Он умеет: создавать и использовать виртуальные окружения, фиксировать версии в lock-файле, ставить зависимости молниеносно и даже управлять установленными версиями Python. Главное для нашего проекта: все установки выполняются **только внутри активированного виртуального окружения** или в окружении, которое создаёт сам `uv` в папке проекта.

---

### 🚀 Шаг 1: Проверяем, что `uv` доступен

```bash
uv --version
```

👉 Показывает версию `uv`. Если команды нет, установите `uv` системно согласно официальной инструкции. В рамках проекта предполагаем, что `uv` уже доступен в терминале.

**Ожидаемый результат (пример):**

```text
uv 0.x.y
```

---

### 🔑 Шаг 2: Активируем окружение или создаём новое под проект

Если у вас уже есть окружение `.venv`, просто активируйте его (как описано в разделе `venv`). Все последующие команды `uv` будут работать **внутри активированного окружения**.

Либо создайте окружение через `uv` рядом с проектом:

```bash
uv venv .venv
```

👉 Создаёт виртуальное окружение в папке `.venv`. После этого активируйте его обычным способом:

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

**macOS/Linux:**

```bash
source .venv/bin/activate
```

**Ожидаемый результат:** в приглашении терминала появится префикс `(.venv)`.

---

### 📦 Шаг 3: Быстрая установка пакетов (совместимый режим `pip`)

Работая в активированном окружении, используйте `uv` как ускоренный аналог `pip`:

```bash
uv pip install requests
```

👉 Устанавливает пакет **в текущем активном окружении**.

```bash
uv pip install "requests==2.32.3"
```

👉 Ставит точную версию для воспроизводимости.

```bash
uv pip install -r requirements.txt
```

👉 Устанавливает зависимости из файла со списком версий.

Проверка, что пакет доступен из окружения:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Должно напечатать «OK», версию и путь к интерпретатору из `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧾 Шаг 4: Генерируем и используем зафиксированные списки версий

`uv` умеет функции `pip-tools` для детерминированных установок:

```bash
uv pip compile requirements.in -o requirements.txt
```

👉 Разрешает зависимости из `requirements.in` и пишет **зафиксированные** версии в `requirements.txt`.

```bash
uv pip sync requirements.txt
```

👉 Синхронизирует окружение строго под `requirements.txt` (установит недостающие и удалит лишние пакеты).

**Ожидаемый результат:** окружение содержит ровно те версии, что указаны в `requirements.txt`.

---

### 📄 Шаг 5: Работа через `pyproject.toml` и lock-файл проекта

Альтернативный поток — управлять зависимостями проектно, без `requirements.txt`.

Инициализируем проект:

```bash
uv init
```

👉 Создаёт базовый `pyproject.toml` и файлы конфигурации проекта.

Добавляем зависимости и фиксируем их в lock-файле проекта:

```bash
uv add requests==2.32.3
```

👉 Записывает зависимость в `pyproject.toml`, пересчитывает lock и устанавливает пакеты в окружение.

Синхронизируем окружение строго по lock-файлу:

```bash
uv sync --frozen
```

👉 Устанавливает пакеты **только** из lock-файла; команда упадёт, если lock не соответствует `pyproject.toml`.

Смотрим дерево зависимостей:

```bash
uv tree
```

👉 Показывает, какие версии и через что подтянулись.

**Ожидаемый результат:** в проекте рядом с `pyproject.toml` появляется lock-файл (например, `uv.lock`), а окружение соответствует ему.

> Мини-справка: `pyproject.toml` должен содержать ограничение версии Python, например:

```toml
[project]
name = "my_project"
version = "0.1.0"
requires-python = ">=3.12,<3.13"
```

👉 Это помогает `uv` подбирать корректные версии пакетов и интерпретатора.

---

### 🐍 Шаг 6: Управление версиями Python и запуск команд

Устанавливаем нужную версию Python под проект:

```bash
uv python install 3.12
```

👉 Ставит указанную версию интерпретатора, если её нет локально.

Запускаем команды в контексте проекта и окружения:

```bash
uv run python --version
```

👉 Гарантирует, что используется интерпретатор и пакеты из вашего проекта.

```bash
uv run -m pytest
```

👉 Запускает тесты, гарантируя корректное окружение.

---

### 📜 Шаг 7: «Импорт» для `uv`

Импорт в коде не нужен: `uv` — инструмент командной строки. Работает через команды выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                 # виртуальное окружение проекта
├─ pyproject.toml         # метаданные и список зависимостей (вариант с проектным управлением)
├─ uv.lock                # lock-файл с зафиксированными версиями (появится после add/sync)
├─ requirements.in        # исходные требования (вариант с requirements)
├─ requirements.txt       # зафиксированные версии (после compile)
└─ your_code.py
```

👉 У вас воспроизводимое окружение: зависимости фиксируются в lock или в `requirements.txt`, установки проходят быстро и **только** в проектное окружение. Команды `uv` гарантируют одинаковые версии на любой машине.

## pip-tools

**pip-tools** — набор утилит для детерминируемых установок:

* `pip-compile` генерирует **зафиксированный** список версий (`requirements.txt`) из декларативного файла (`requirements.in` или `pyproject.toml`).
* `pip-sync` приводит окружение к этим версиям: установит нужное и удалит лишнее.

Работайте **только в активированном виртуальном окружении** проекта.

---

### 🚀 Шаг 1: Устанавливаем `pip-tools` в окружение

```bash
python -m pip install pip-tools
```

👉 Ставит пакет `pip-tools` в текущее активированное окружение. Появятся команды `pip-compile` и `pip-sync`.

**Ожидаемый результат (пример):**

```text
Successfully installed pip-tools-7.x
```

---

### 📄 Шаг 2: Описываем верхнеуровневые зависимости

Создайте файл `requirements.in` и перечислите **только** то, что вы напрямую используете в коде (без транзитивных зависимостей):

```text
requests==2.32.3
uvicorn>=0.30
```

👉 Это декларативный список «хочу такие пакеты». Версии можно фиксировать строго (`==`) или задавать нижнюю границу (`>=`).

> Альтернатива: можно компилировать из `pyproject.toml`.

---

### 🧮 Шаг 3: Компилируем фиксированные версии

```bash
pip-compile requirements.in -o requirements.txt
```

👉 Разрешает все зависимости и записывает **точные** версии в `requirements.txt`. Этот файл стабильный и переносимый.

Полезные варианты:

```bash
pip-compile --upgrade -o requirements.txt requirements.in
```

👉 Обновляет все версии до последних совместимых.

```bash
pip-compile --upgrade-package requests -o requirements.txt requirements.in
```

👉 Точечно обновляет один пакет (и его дерево зависимостей).

```bash
pip-compile --generate-hashes -o requirements.txt requirements.in
```

👉 Добавляет криптохеши для каждой колёсной сборки/архива. Повышает безопасность и детерминизм.

**Ожидаемый результат (фрагмент):**

```text
# This file is autogenerated by pip-compile
requests==2.32.3 \
    --hash=sha256:<hash1> \
    --hash=sha256:<hash2>
urllib3==2.2.3 \
    --hash=sha256:<hashA> \
    --hash=sha256:<hashB>
```

---

### 🔁 Шаг 4: Синхронизируем окружение по зафиксированным версиям

```bash
pip-sync requirements.txt
```

👉 Приводит окружение **строго** к `requirements.txt`: установит недостающие версии и удалит пакеты, которых в файле нет.

Осторожный режим:

```bash
pip-sync --dry-run requirements.txt
```

👉 Покажет план изменений без выполнения.

**Ожидаемый результат:** вывод с установкой/удалением, после чего `pip list` совпадает с `requirements.txt`.

---

### 🧪 Шаг 5: Проверяем, что пакеты ставятся из окружения

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Печатает версию `requests` и путь к интерпретатору. Путь должен указывать на `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🧰 Шаг 6: Дополнительно — работа с `pyproject.toml`

Если вы храните зависимости в `pyproject.toml`, можно компилировать прямо из него:

```bash
pip-compile -o requirements.txt pyproject.toml
```

👉 Считывает раздел с зависимостями проекта и формирует фиксированный `requirements.txt`.

Экстры (если используются):

```bash
pip-compile -o requirements-dev.txt --extra dev pyproject.toml
```

👉 Собирает зависимости для дополнительного профиля, например `dev`.

---

### 🎯 Результат (что должно получиться?)

```text
project/
├─ .venv/
├─ requirements.in        # декларативный список верхнеуровневых зависимостей
├─ requirements.txt       # зафиксированный, переносимый список версий (с хешами, если включили)
├─ pyproject.toml         # опционально: источник зависимостей для compile
└─ your_code.py
```

👉 Проект воспроизводим: версии фиксируются `pip-compile`, окружение синхронизируется `pip-sync`. Устанавливайте и обновляйте зависимости предсказуемо на любой машине.

## virtualenv

**virtualenv** — продвинутая утилита для создания виртуальных окружений. По сравнению с `venv` она гибче и обычно быстрее, особенно если нужна **нестандартная версия Python** или тонкая настройка. Все установки выполняйте **только в активированном окружении проекта**.

---

### 🚦 Шаг 1: Проверяем, что `virtualenv` доступен

```bash
virtualenv --version
```

👉 Показывает версию утилиты. Если команда не найдена, установите `virtualenv` заранее (в рамках гайда считаем, что она уже доступна в системе).

**Ожидаемый результат (пример):**

```text
virtualenv 20.x.y from ...
```

---

### 🏗️ Шаг 2: Создаём окружение рядом с проектом

Быстрый старт (интерпретатор по умолчанию):

```bash
virtualenv .venv
```

👉 Создаёт папку `.venv` со своим Python и `pip`. По умолчанию используются симлинки, что ускоряет работу.

Создание с обновлением «посевных» инструментов:

```bash
virtualenv .venv --upgrade-deps
```

👉 Сразу подтягивает свежие версии `pip`, `setuptools`, `wheel` внутри окружения.

Задаём человекочитаемый префикс в приглашении:

```bash
virtualenv .venv --prompt "proj"
```

👉 После активации в начале строки будет `(proj)` вместо `(.venv)` — удобно, когда окружений много.

**Ожидаемый результат:** в проекте появляется каталог `.venv/` (`bin/` на macOS/Linux или `Scripts/` на Windows, плюс `lib/` с пакетами).

---

### 🔢 Шаг 3: Выбираем конкретную версию Python

Если нужен другой Python (например, 3.12), укажите путь или используйте лаунчер:

**macOS/Linux (через путь):**

```bash
virtualenv -p /usr/bin/python3.12 .venv312
```

👉 Берёт интерпретатор по указанному пути и создаёт окружение `.venv312`.

**Кроссплатформенно (если доступен нужный интерпретатор в PATH):**

```bash
virtualenv -p python3.12 .venv312
```

👉 Попросит системный PATH выдать `python3.12` и соберёт окружение на этой версии.

**Windows (с лаунчером py):**

```bat
py -3.11 -m virtualenv .venv311
```

👉 Запускает модуль `virtualenv` под Python 3.11 и создаёт окружение `.venv311`.

**Ожидаемый результат:** отдельные папки окружений для нужных версий: `.venv312/`, `.venv311/` и т. д.

---

### 🔑 Шаг 4: Активируем окружение

**Windows (PowerShell):**

```powershell
.\.venv\Scripts\Activate.ps1
```

**Windows (cmd.exe):**

```bat
.\.venv\Scripts\activate.bat
```

**macOS/Linux:**

```bash
source .venv/bin/activate
```

👉 Скрипт активации меняет переменные среды текущего процесса. В приглашении появится префикс окружения.

**Ожидаемый результат (пример):**

```text
(.venv) user@host project $
```

Чтобы выйти:

```bash
deactivate
```

👉 Возвращает терминал к системному Python.

---

### 🧰 Шаг 5: Устанавливаем и проверяем пакеты внутри окружения

Сначала обновим `pip` именно в этом окружении:

```bash
python -m pip install --upgrade pip
```

👉 Меньше сюрпризов при установке библиотек.

Устанавливаем зависимости **только после активации**:

```bash
pip install requests
```

👉 Ставит пакет в `.venv`.

Проверка, что всё в нужном месте:

```bash
python -c "import requests, sys; print('OK', requests.__version__, sys.executable)"
```

👉 Должно вывести «OK», версию и путь к интерпретатору из `.venv`.

**Ожидаемый результат (пример):**

```text
OK 2.32.3 /path/to/project/.venv/bin/python
```

---

### 🔁 Шаг 6: Воспроизводим окружение на другой машине

Сохраняем точные версии в файл:

```bash
python -m pip freeze > requirements.txt
```

👉 Фиксирует полный снимок окружения.

Воссоздаём окружение из файла на другой машине:

```bash
virtualenv .venv
source .venv/bin/activate   # или эквивалент для Windows
python -m pip install -r requirements.txt
```

👉 Получаем те же версии пакетов и предсказуемый запуск кода.

---

### 🔧 Шаг 7: Полезные параметры настройки

Копии вместо симлинков (актуально для сетевых дисков/контейнеров):

```bash
virtualenv .venv --copies
```

👉 Использует физические копии файлов Python, когда симлинки нежелательны.

Чистая пересборка окружения в той же папке:

```bash
rm -rf .venv && virtualenv .venv --upgrade-deps
```

👉 Полное пере‑создание окружения с обновлёнными инструментами.

---

### 📜 «Импорт» для `virtualenv`

Импорта в коде нет — это CLI‑утилита. Вся работа выполняется командами выше.

---

### 🎉 Результат (что должно получиться?)

```text
project/
├─ .venv/                 # виртуальное окружение проекта (или .venv311, .venv312 и т. п.)
├─ requirements.txt       # зафиксированные версии (если используете freeze)
└─ your_code.py
```

👉 У вас изолированное и при необходимости многоверсионное окружение. Все пакеты ставятся внутрь `.venv`, а проект воспроизводится на любой машине.


